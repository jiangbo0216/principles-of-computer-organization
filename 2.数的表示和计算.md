## 进制

二进制的小数只能表述$1/2, 1/4, 1/8, ..., 1/2^{n}$

## BCD码(Binary-Coded Decimal)

8421 越界之后 + 6 进行修正
![](2.数的表示和计算-imgs/20201108162102.png)

余3码是无权码

![](2.数的表示和计算-imgs/20201108162327.png)

## ASCII

![](2.数的表示和计算-imgs/20201108162643.png)

可印刷字符: 32 ~ 126, 其余为控制, 通信字符

0-9: 48 (0011 0000) - 51 (0011 1001) 8421 码规则

运用这个规律直接写出字母的ASCII码

大写字母: 65 (0100 0001) - 90 (0101 1010) 二进制数字的1-26

小写字母: 65 (0110 0001) - 90 (0111 1010) 二进制数字的1-26

## 汉字的表示和编码

![](2.数的表示和计算-imgs/20201108163722.png)

+20H是避免与控制和通信字符冲突(满足数据传输的要求, 但是存储到计算机会和ASCII码冲突)
+80H避免和ASCII码冲突

![](2.数的表示和计算-imgs/20201108164011.png)

## 字符串

![](2.数的表示和计算-imgs/20201108164106.png)

![](2.数的表示和计算-imgs/20201108164149.png)

## 奇偶校验码

注意码距的概念: 合法码字间最小距离称为**码距**

码距越大, 检错纠错能力越强

奇校验, 校验码中1的个数为奇数

![](2.数的表示和计算-imgs/20201108164606.png)

![](2.数的表示和计算-imgs/20201108164842.png)

![](2.数的表示和计算-imgs/20201108165003.png)

## 海明码

设计思路: 将信息为分组进行偶校验->多个校验位->多个校验位标注出错误

海明码具有1位纠错能力, 2位检错能力

![](2.数的表示和计算-imgs/20201108170043.png)

![](2.数的表示和计算-imgs/20201108173632.png)

![](2.数的表示和计算-imgs/20201108173749.png)

加上全校验位之后需要满足等式$2^{k-1} >=  n + k + 1$

## 循环冗余检验码

只看最高位, 模二减和异或运算是一样的

生成多项式最高次幂位R, 移位为R

![](2.数的表示和计算-imgs/20201108174722.png)

![](2.数的表示和计算-imgs/20201108174957.png)

## 定点数和浮点数(小数点的位置, 常规计数和科学计数法)

* 无符号数
* 有符号数
  * 原码
  * 反码
  * 补码
  * 移码

### 无符号数

通常只有整数没有小数(对应c语言中没有 unsigned float)

0 ~ 2^{n} - 1
![](2.数的表示和计算-imgs/20201108234715.png)

### 有符号数

可用 原码、反码、补码 三种方式来表示定
点整数和定点小数。还可用 移码 表示定点整数

![](2.数的表示和计算-imgs/20201108235421.png)

#### 原码

真值0有 +0 和 -0 两种形式

若机器字长n+1位，原码整数的表示范围：$-(2^{n}-1)=<x<=2^{n}-1$（关于原点对称）
等比数列求和公式 $S_{n}=\frac{a_{1}*(q^n-1)}{q-1}$
同理原码小数的表示范围为$-(1-2^{-n}) =<x<= 1 - 2^{-n}$

#### 反码

“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用

#### 补码

定点整数补码 [x]补 = 1,0000000 表示 $x = -2^{7}$
若机器字长n+1位，补码整数的表示范围：
$−2^{n} ≤ x ≤ 2{n}−1$ （比原码多表示一个 −2n ）
定点小数补码 [x]补 = 1.0000000 表示 x = -1
若机器字长n+1位，补码小数的表示范围：
$−1 ≤ x ≤ 1−2^{−n}$ （比原码多表示一个 −1 ）

#### 移码

移码： 补码的基础上将符号位取反。注意：移码只能用于表示整数

方便对比大小

### 各种码的作用

补码的作用： 使用补码可将减法操作转变为等价的加法，ALU 中无需集成减法器。
执行加法操作时，符号位一起参与运算

### 补码转换为原码

负数补->原：①数值位取反+1；②负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码(所以转换方法, 是找到最右边的1, 前面的取反后面的不动即可得到原码)

## 算数移位

### 原码的算术移位

原码的算数移位——符号位保持不变，仅对数值位进行移位。

* 右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度
* 左移：低位补0，高位舍弃。若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差

### 补码的算数移位

补码的算数移位——正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。

* 右移：高位补0，低位舍弃。
* 左移：低位补0，高位舍弃。

反码的算数移位——正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。

* 右移：高位补0，低位舍弃。
* 左移：低位补0，高位舍弃。

反码的算数移位——负数的反码数值位与原码相反，因此负数反码的移位运算规则如下，

* 右移：高位补1，低位舍弃。
* 左移：低位补1，高位舍弃。

补码的算数移位——负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码负数补码的算数移位规则如下：

* 右移（同反码）：高位补1，低位舍弃。
* 左移（同原码）：低位补0，高位舍弃。

### 逻辑移位

逻辑右移：高位补0，低位舍弃。逻辑左移：低位补0，高位舍弃。

可以把逻辑移位看作是对“无符号数”的算数移位
